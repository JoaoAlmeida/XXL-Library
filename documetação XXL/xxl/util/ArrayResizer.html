<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN""http://www.w3.org/TR/REC-html40/frameset.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Fri Jan 26 20:29:48 CET 2001 -->
<TITLE>
XXL - The eXtensible and fleXible Library for data processing: Class  ArrayResizer
</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">
</HEAD>
<BODY BGCOLOR="white">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT ID="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT ID="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT ID="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT ID="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT ID="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<a href=http://www.mathematik.uni-marburg.de/DBS/xxl target=_parent><img src=xxl.gif border=0 alt=home-page></a></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../xxl/util/BitSet.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="ArrayResizer.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
xxl.util</FONT>
<BR>
Class  ArrayResizer</H2>
<PRE>
<A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html">java.lang.Object</A>
  |
  +--<B>xxl.util.ArrayResizer</B>
</PRE>
<HR>
<DL>
<DT>public class <B>ArrayResizer</B><DT>extends <A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html">Object</A></DL>

<P>
The ArrayResizer provides methods that allow to modify the size of a
 given array after its construction. <br>
 An ArrayResizer is especially useful with regard to dynamic structures based
 on arrays, because this class supports methods to expanded or shrink an array
 depending on user specified parameters.<p>
 Therefore the user has to consider this two kinds of sizes of an array:
 <ul>
 <li><b>logical size</b>: a user specified size that represents the minimum needed size
 			of the array after the resize-operation.</li>
 <li><b>physical size</b>: the actual returned size of a given array after a resize-
			operation.</li>
 </ul>
 An instance of ArrayResizer can be created with the parameters <tt>fmin</tt>,
 <tt>fover</tt>, <tt>funder</tt>, which refer to these two sizes of an array.<p>
 <b>IMPORTANT:</b><br>
 These parameters have to be specified with a value in a range of [0,1]! (per cent values)
 <ul>
 <li><tt><b>fmin</b></tt> is the minimal utilization of capacity concerning
		 the ratio between logical and physical size after an expansion or
		 contraction of an array.
		 The following condition is valid:
		 logical size * fmin <= physical size * fmin <= logical size
 		 <ul>
 		<li><b>expansion:</b><br>
 			<pre>	fmin = 0: logical size = physical size * fover </pre><br>
 			<pre>	fmin = 1: logical size = physical size <br></pre></li>
 		<li><b>contraction:</b><br>
 			<pre>	fmin = 0: logical size = physical size * funder </pre><br>
 			<pre>	fmin = 1: logical size = physical size </pre><br></li>
 </ul></li>
 <li><tt><b>fover</b></tt> is a parameter specifying the array's logical size
 		in proportion to the array's physical size after an expansion. <br>
 		<pre>	fover = 0: logical size = fmin * physical size </pre><br>
 		<pre>	fover = 1: logical size = physical size </pre><br></li>
 <li><tt><b>funder</b></tt> is a parameter specifying the array's logical size
 		in proportion to the array's physical size after a contraction. <br>
 		<pre>	funder = 0: logical size = fmin * physical size </pre><br>
 		<pre>	funder = 1: logical size = physical size </pre><br></li>
 </ul><p>
 To resize a given (Object or primitive type) array, one of the resize-methods
 of this class has to be called. Therefore an the array to be resized and the minimum
 <tt>size</tt> (logical size) the array should have afer a contraction
 or an expanison has to be specified.
 Depending on this parameter <tt>size</tt> (logical size) and the array's length the given
 array is expanded, i.e. the method <code>grow(array, size)</code> is called,
 or shrinked, i.e.<code>shrink(array, size)</code> is called.<br>
 <b>Note:</b> The specified parameter <tt>size</tt> represents the minimum size (logical size)
 an array can have after a resize-operation. The actual physical size after a resize-
 operation is determined by the parameters <tt>fover</tt> (grow-operation) and <tt>funder</tt>
 (shrink-operation) in the following way:<br>
 <ul>
 <li>	grow: returned size = (int)(size / (fover+(1-fover)*fmin))
 <li>	shrink: returned size = (int) (size / (funder+(1-funder)*fmin))
 </ul>
 So the following <b>invariant conditions</b> are still valid:
 <ul>
 <li>	<b>grow</b>:
 		<pre>	<tt>logical size * fmin <= physical size * fmin <= logical size</tt></pre><br>
 		<pre>	<tt>logical size * fover <= physical size * fover <= logical size</tt></pre></li>
 <li>	<b>shrink</b>:
 		<pre>	<tt>logical size * fmin <= physical size * fmin <= logical size</tt></pre><br>
 		<pre>	<tt>logical size * funder <= physical size * funder <= logical size</tt></pre></li>
 </ul><p>

 Further this class provides some useful methods to copy arrays and contains
 a static field DEFAULT_INSTANCE, which is similar to the design pattern, named Singleton except
 that there are no mechanisms to avoid the creation of other instances. <br>
 <b>Intent:</b><br>
 "Ensure a class only has one instance, and provide a global point of access to it."<br>
 For further information see: "Gamma et al.: <i>DesignPatterns</i>. Addision Wesley 1998."
 <p>

 <b>Example usage (1):</b>
 <br><br>
 <code><pre>
 	ArrayResizer arrayResizer = ArrayResizer.DEFAULT_INSTANCE; // get a default instance
 	int[] ints = new int[10]; // use a primitive type array
 	int size = 20; // minimal needed size (logical size) --> grow
 	int[] resizedArray = (int[])arrayResizer.resize(ints, size); // resize-call
 </code></pre>
 This examples creates a new default instance of this class and calls the <tt>resize</tt>
 method for a primitive type (int) array. By using a default instance of this class,
 the fiels <tt>fmin</tt>, <tt>fover</tt>, <tt>funder</tt> are initialized with '0.5'.<br>
 The logical size is set to '20'.<br>
 The initial array size is '10' so the ArrayResizer calls <tt>grow(ints, 20)</tt>.
 So the returned size, i.e. the physical size, is '26', because <br>
 <pre>
 	(grow: <code>return (int)(size / (fover+(1-fover)*fmin)</code>) <br>
 	==> (int)(20/(0.5+(1-0.5)*0.5) = 26 <br>
 </pre><p>

 <b>Example usage (2):</b>
 <br><br>
 <code><pre>
 	arrayResizer = new ArrayResizer(0.2); // create new ArrayResizer with fmin = 0.2
 	ints = new int[100]; // use a primitive type array
 	size = 10; // minimal needed size (logical size) --> shrink
 	resizedArray = (int[])arrayResizer.resize(ints, size); // resize-call
 </code></pre>
 In this case a new instance of ArrayResizer is created by specifying
 <tt>fmin</tt> with value '0.2'. The other fields <tt>fover</tt> and <tt>fmin</tt>
 are set to '0.5'. Because the array has an initial array size of '100' and the
 logical size is specified with '10' the array has to be shrinked. Therefore the
 <tt>resize</tt> method calls <code>shrink(ints, 10)</code>.<br>
 Because of <tt>fmin</tt> the physical array size has to be 20 per cent larger (or even more)
 than the logical array size. So the actual physical size is determined by: <br>
 	(shrink: <code>return (int)(size / (funder+(1-funder)*fmin)</code>) <br>
 So the returned physical size is '16'.<p>

 <b>Example usage (3):</b>
 <br><br>
 <code><pre>
 	System.out.println("------------------EXAMPLE 3-------------------");
 	// create new ArrayResizer with fmin = 0.2, fover = 0.6 and funder = 0.8
 	arrayResizer = new ArrayResizer(0.2, 0.6, 0.8);
 	// use an Object array
 	Integer[] objects = new Integer[]{new Integer(0), new Integer(1), new Integer(2)};
 	size = 10; // minimal needed size (logical size) --> grow
 	Integer[] resizedObjectArray = (Integer[])arrayResizer.resize(objects, size); // resize-call
 	System.out.println("initial array size:" +objects.length);
 	System.out.println("logical size:  " +size);
 	System.out.println("physical size: " +resizedObjectArray.length +" (returned size!)");
 	System.out.println("fover:         " +arrayResizer.fover);
 	System.out.println("funder:        " +arrayResizer.funder);
 	System.out.println("fmin:          " +arrayResizer.fmin);
 	System.out.println("logical size * fover:    " +size*arrayResizer.fover);
 	System.out.println("logical size * funder:   " +size*arrayResizer.funder);
 	System.out.println("logical size * fmin:     " +size*arrayResizer.fmin);
 	System.out.println("physical size * fover:    " +resizedArray.length*arrayResizer.fover);
 	System.out.println("physical size * funder:   " +resizedArray.length*arrayResizer.funder);
 	System.out.println("physical size * fmin:    " +(int)(resizedObjectArray.length*arrayResizer.fmin));
 	System.out.println("NOTE the following conditions:");
 	System.out.println("general:          logical size * fmin <= physical size * fmin <= logical size");
 	System.out.println("grow-operation:   logical size * fover <= physical size * fover <= logical size");
 	System.out.println("shrink-operation: logical size * funder <= physical size * funder <= logical size");
 	System.out.println();
 </code></pre>
 This last example demonstrates the most complex constructor that can be used to create an
 an instance of ArrayResizer. Further it demonstrates the usage of Object-type arrays
 concerning the <tt>resize</tt> method. The initial array size is '3', therefore an expansion
 has to be made to gain a minimum logical size of '10'. <br>
 Further the output shows the used sizes, the used parameters and their relations, i.e. the
 invariant conditions.<p>

 Every example shown above generates an output like example (3) if you run the
 use cases.
<P>
<DL>
<DT><B>See Also: </B><DD><A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/reflect/Array.html"><CODE>Array</CODE></A>, 
<CODE>System.arraycopy(java.lang.Object, int, java.lang.Object, int, int)</CODE>, 
<A HREF="../../xxl/collections/ArrayQueue.html"><CODE>ArrayQueue</CODE></A>, 
<A HREF="../../xxl/collections/DynamicHeap.html"><CODE>DynamicHeap</CODE></A></DL>
<HR>

<P>
<!-- ======== INNER CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../xxl/util/ArrayResizer.html">ArrayResizer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../xxl/util/ArrayResizer.html#DEFAULT_INSTANCE">DEFAULT_INSTANCE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This instance can be used for getting a default instance of
 ArrayResizer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../xxl/util/ArrayResizer.html#fmin">fmin</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>fmin</tt> is the minimal utilization of capacity concerning
 the ratio between logical and physical size after an expansion or
 contraction of an array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../xxl/util/ArrayResizer.html#fover">fover</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>fover</tt> is a parameter specifying the array's logical size
 in proportion to the array's physical size after an expansion.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../xxl/util/ArrayResizer.html#funder">funder</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>funder</tt> is a parameter specifying the array's logical size
 in proportion to the array's physical size after a contraction.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../xxl/util/ArrayResizer.html#ArrayResizer()">ArrayResizer</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new ArrayResizer using a default value of <tt>fmin = 0.5</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../xxl/util/ArrayResizer.html#ArrayResizer(double)">ArrayResizer</A></B>(double&nbsp;fmin)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new ArrayResizer using default values of <tt>fover = funder = 0.5</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../xxl/util/ArrayResizer.html#ArrayResizer(double, double)">ArrayResizer</A></B>(double&nbsp;fmin,
             double&nbsp;f)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new ArrayResizer by initializing <tt>fover</tt> and
 <tt>funder</tt> with the same given value <tt>f</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../xxl/util/ArrayResizer.html#ArrayResizer(double, double, double)">ArrayResizer</A></B>(double&nbsp;fmin,
             double&nbsp;fover,
             double&nbsp;funder)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new ArrayResizer.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../xxl/util/ArrayResizer.html#copy(java.lang.Object, int, java.lang.Object, int, int)">copy</A></B>(<A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html">Object</A>&nbsp;source,
     int&nbsp;from,
     <A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html">Object</A>&nbsp;target,
     int&nbsp;to,
     int&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies an array from the specified source array, beginning at the
 specified position, to the specified position of the destination array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../xxl/util/ArrayResizer.html#copy(java.lang.Object, java.lang.Object, int)">copy</A></B>(<A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html">Object</A>&nbsp;source,
     <A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html">Object</A>&nbsp;target,
     int&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies an array from the specified source array at position 0
 to position 0 of the destination array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../xxl/util/ArrayResizer.html#grow(java.lang.Object, int)">grow</A></B>(<A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html">Object</A>&nbsp;array,
     int&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a new array with a minimum size of <tt>size</tt> after the expansion.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../xxl/util/ArrayResizer.html#main(java.lang.String[])">main</A></B>(<A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/String.html">String</A>[]&nbsp;args)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The main method contains some examples to demonstrate the usage
 and the functionality of this class.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html">Object</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../xxl/util/ArrayResizer.html#resize(java.lang.Object[], int)">resize</A></B>(<A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html">Object</A>[]&nbsp;array,
       int&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Resizes a given Object-array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../xxl/util/ArrayResizer.html#resize(java.lang.Object, int)">resize</A></B>(<A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html">Object</A>&nbsp;array,
       int&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Resizes a given (Object or primitive type) array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../xxl/util/ArrayResizer.html#shrink(java.lang.Object, int)">shrink</A></B>(<A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html">Object</A>&nbsp;array,
       int&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a new array with a minimum size of <tt>size</tt> after the contraction.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.<A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html">Object</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html#clone()">clone</A>, 
<A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html#equals(java.lang.Object)">equals</A>, 
<A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html#finalize()">finalize</A>, 
<A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html#getClass()">getClass</A>, 
<A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html#hashCode()">hashCode</A>, 
<A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html#notify()">notify</A>, 
<A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html#notifyAll()">notifyAll</A>, 
<A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html#toString()">toString</A>, 
<A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html#wait()">wait</A>, 
<A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html#wait(long)">wait</A>, 
<A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html#wait(long, int)">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="fmin"><!-- --></A><H3>
fmin</H3>
<PRE>
protected double <B>fmin</B></PRE>
<DL>
<DD><tt>fmin</tt> is the minimal utilization of capacity concerning
 the ratio between logical and physical size after an expansion or
 contraction of an array.
 The following condition is valid:
 	logical size * fmin <= physical size * fmin <= logical size
 <ul>
 <li><b>expansion:</b><br>
 	<pre>	fmin = 0: logical size = physical size * fover </pre><br>
 	<pre>	fmin = 1: logical size = physical size </pre><br></li>
 <li><b>contraction:</b><br>
	<pre>	fmin = 0: logical size = physical size * funder </pre><br>
 	<pre>	fmin = 1: logical size = physical size </pre><br></li>
 </ul></DL>
<HR>

<A NAME="fover"><!-- --></A><H3>
fover</H3>
<PRE>
protected double <B>fover</B></PRE>
<DL>
<DD><tt>fover</tt> is a parameter specifying the array's logical size
 in proportion to the array's physical size after an expansion. <br>
 	<pre>	fover = 0: logical size = fmin * physical size </pre><br>
 	<pre>	fover = 1: logical size = physical size </pre><br></DL>
<HR>

<A NAME="funder"><!-- --></A><H3>
funder</H3>
<PRE>
protected double <B>funder</B></PRE>
<DL>
<DD><tt>funder</tt> is a parameter specifying the array's logical size
 in proportion to the array's physical size after a contraction. <br>
 	<pre>	funder = 0: logical size = fmin * physical size </pre><br>
 	<pre>	funder = 1: logical size = physical size </pre><br></DL>
<HR>

<A NAME="DEFAULT_INSTANCE"><!-- --></A><H3>
DEFAULT_INSTANCE</H3>
<PRE>
public static final <A HREF="../../xxl/util/ArrayResizer.html">ArrayResizer</A> <B>DEFAULT_INSTANCE</B></PRE>
<DL>
<DD>This instance can be used for getting a default instance of
 ArrayResizer. It is similar to the <i>Singleton Design Pattern</i>
 (for further details see Creational Patterns, Singleton in
 <i>Design Patterns: Elements of Reusable Object-Oriented
 Software</i> by Erich Gamma, Richard Helm, Ralph Johnson, and John
 Vlissides) except that there are no mechanisms to avoid the
 creation of other instances of ArrayResizer.</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="ArrayResizer()"><!-- --></A><H3>
ArrayResizer</H3>
<PRE>
public <B>ArrayResizer</B>()</PRE>
<DL>
<DD>Creates a new ArrayResizer using a default value of <tt>fmin = 0.5</tt>.</DL>
<HR>

<A NAME="ArrayResizer(double)"><!-- --></A><H3>
ArrayResizer</H3>
<PRE>
public <B>ArrayResizer</B>(double&nbsp;fmin)</PRE>
<DL>
<DD>Creates a new ArrayResizer using default values of <tt>fover = funder = 0.5</tt>.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>fmin</CODE> - is the minimal utilization of capacity concerning
 		the ratio between logical and physical size after an expansion or
 		contraction of an array.
 		<ul>
 		<li><b>expansion:</b><br>
 			<pre>	fmin = 0: logical size = physical size * fover </pre><br>
 			<pre>	fmin = 1: logical size = physical size </pre><br></li>
 		<li><b>contraction:</b><br>
			<pre>	fmin = 0: logical size = physical size * funder </pre><br>
 			<pre>	fmin = 1: logical size = physical size </pre><br></li>
 		</ul></DL>
</DD>
</DL>
<HR>

<A NAME="ArrayResizer(double, double)"><!-- --></A><H3>
ArrayResizer</H3>
<PRE>
public <B>ArrayResizer</B>(double&nbsp;fmin,
                    double&nbsp;f)</PRE>
<DL>
<DD>Creates a new ArrayResizer by initializing <tt>fover</tt> and
 <tt>funder</tt> with the same given value <tt>f</tt>.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>fmin</CODE> - is the minimal utilization of capacity concerning
 		the ratio between logical and physical size after an expansion or
 		contraction of an array.
 		<ul>
 		<li><b>expansion:</b><br>
 			<pre>	fmin = 0: logical size = physical size * fover </pre><br>
 			<pre>	fmin = 1: logical size = physical size </pre><br></li>
 		<li><b>contraction:</b><br>
			<pre>	fmin = 0: logical size = physical size * funder </pre><br>
 			<pre>	fmin = 1: logical size = physical size </pre><br></li>
 		</ul><DD><CODE>f</CODE> - parameter specifying the array's logical size in proportion to the array's
 		physical size after an expansion or contraction. Thats means <tt>fover</tt> and
 		<tt>funder</tt> are initialized with the same value <tt>f</tt>.</DL>
</DD>
</DL>
<HR>

<A NAME="ArrayResizer(double, double, double)"><!-- --></A><H3>
ArrayResizer</H3>
<PRE>
public <B>ArrayResizer</B>(double&nbsp;fmin,
                    double&nbsp;fover,
                    double&nbsp;funder)</PRE>
<DL>
<DD>Creates a new ArrayResizer.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>fmin</CODE> - is the minimal utilization of capacity concerning
 		the ratio between logical and physical size after an expansion or
 		contraction of an array.
 		<ul>
 		<li><b>expansion:</b><br>
 			<pre>	fmin = 0: logical size = physical size * fover </pre><br>
 			<pre>	fmin = 1: logical size = physical size </pre><br></li>
 		<li><b>contraction:</b><br>
			<pre>	fmin = 0: logical size = physical size * funder </pre><br>
 			<pre>	fmin = 1: logical size = physical size </pre><br></li>
 		</ul><DD><CODE>fover</CODE> - a parameter specifying the array's logical size
 		in proportion to the array's physical size after an expansion. <br>
 		<pre>	fover = 0: logical size = fmin * physical size </pre><br>
 		<pre>	fover = 1: logical size = physical size </pre><br><DD><CODE>funder</CODE> - a parameter specifying the array's logical size
 		in proportion to the array's physical size after a contraction. <br>
 		<pre>	funder = 0: logical size = fmin * physical size <br>
 		<pre>	funder = 1: logical size = physical size <br></DL>
</DD>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="grow(java.lang.Object, int)"><!-- --></A><H3>
grow</H3>
<PRE>
public <A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html">Object</A> <B>grow</B>(<A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html">Object</A>&nbsp;array,
                   int&nbsp;size)</PRE>
<DL>
<DD>Returns a new array with a minimum size of <tt>size</tt> after the expansion.
 This parameter <tt>size</tt> is the logical size computed with.
 Creates a new array with the specified component type and a new physical size
 that is computed by:
 <br><br>
 <code><pre>
 	(int)(size/(fover+(1-fover)*fmin))
 </code></pre>
 <b>Note:</b> <tt>fover</tt> is a parameter specifying the array's logical size
 in proportion to the array's physical size after an expansion.
 When <tt>fover = 0 </tt> then an array is created with a new physical size of
 <tt>size / fmin</tt>, i.e. <tt>logical size = fmin * physical size</tt>.
 When <tt>fover = 1</tt> then an array is created were the logical size is equal to
 the physical size.
 To guarantee the <b>invariant conditions</b>
 <pre>
 	<tt>logical size * fmin <= physical size * fmin <= logical size</tt>
 	<tt>logical size * fover <= physical size * fover <= logical size</tt>
 </pre>
 the parameter <tt>size</tt> has not only to be divided by <tt>fover</tt> but by the
 complement of <tt>fover</tt> multiplied by <tt>fmin</tt>.

 Creates a new instance of an array by calling
 <CODE>Array.newInstance(Class, int)</CODE>.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - the array to be expanded.<DD><CODE>size</CODE> - the minimal needed size of the array after an expansion (logical size).<DT><B>Returns:</B><DD>a new array with a physical size computed by <code>(int)(size/(fover+(1-fover)*fmin))</code>.<DT><B>Throws:</B><DD><A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/NullPointerException.html">NullPointerException</A> - if the specified
 		<code>array</code> parameter is null.<DD><A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/NegativeArraySizeException.html">NegativeArraySizeException</A> - if the specified <code>length</code>
 		is negative.</DL>
</DD>
</DL>
<HR>

<A NAME="shrink(java.lang.Object, int)"><!-- --></A><H3>
shrink</H3>
<PRE>
public <A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html">Object</A> <B>shrink</B>(<A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html">Object</A>&nbsp;array,
                     int&nbsp;size)</PRE>
<DL>
<DD>Returns a new array with a minimum size of <tt>size</tt> after the contraction.
 This parameter <tt>size</tt> is the logical size computed with.
 Creates a new array with the specified component type and a new physical size that is
 computed by:
 <br><br>
 <code><pre>
 	(int)(size/(funder+(1-funder)*fmin))
 </code></pre>
 <b>Note:</b> <tt>funder</tt> is a parameter specifying the array's logical size
 in proportion to the array's physical size after a contraction.
 When <tt>funder = 0 </tt> then an array is created with a new physical size of
 <tt>size / fmin</tt>, i.e. <tt>logical size = fmin * physical size</tt>.
 When <tt>funder = 1</tt> then an array is created were the logical size is equal to
 the physical size.
 To guarantee the <b>invariant conditions</b>
 <pre>
 	<tt>logical size * fmin <= physical size * fmin <= logical size</tt>
 	<tt>logical size * funder <= physical size * funder <= logical size</tt>
 </pre>
 the parameter size has not only to be divided by <tt>funder</tt> but by the
 complement of <tt>funder</tt> multiplied by <tt>fmin</tt>.

 Creates a new instance of an array by calling
 <CODE>Array.newInstance(Class, int)</CODE>.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - the array to be shrinked.<DD><CODE>size</CODE> - the minimal needed size of the array after a contraction (logical size).<DT><B>Returns:</B><DD>a new array with a physical size computed by <code>(int)(size/(funder+(1-funder)*fmin))</code>.<DT><B>Throws:</B><DD><A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/NullPointerException.html">NullPointerException</A> - if the specified
 		<code>array</code> parameter is null.<DD><A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/NegativeArraySizeException.html">NegativeArraySizeException</A> - if the specified <code>length</code>
 		is negative.</DL>
</DD>
</DL>
<HR>

<A NAME="copy(java.lang.Object, int, java.lang.Object, int, int)"><!-- --></A><H3>
copy</H3>
<PRE>
public static void <B>copy</B>(<A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html">Object</A>&nbsp;source,
                        int&nbsp;from,
                        <A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html">Object</A>&nbsp;target,
                        int&nbsp;to,
                        int&nbsp;size)</PRE>
<DL>
<DD>Copies an array from the specified source array, beginning at the
 specified position, to the specified position of the destination array.
 A subsequence of array components are copied from the source
 array referenced by <code>source</code> to the destination array
 referenced by <code>target</code>. The number of components copied is
 equal to the <code>size</code> argument. The components at
 positions <code>sourceOffset</code> through
 <code>sourceOffset+size-1</code> in the source array are copied into
 positions <code>targetOffset</code> through
 <code>targetOffset+size-1</code>, respectively, of the destination
 array.
 <p>
 If the <code>source</code> and <code>target</code> arguments refer to the
 same array object, then the copying is performed as if the
 components at positions <code>sourceOffset</code> through
 <code>sourceOffset+size-1</code> were first copied to a temporary
 array with <code>size</code> components and then the contents of
 the temporary array were copied into positions
 <code>targetOffset</code> through <code>targetOffset+size-1</code> of the
 destination array.
 <p>
 If <code>target</code> is <code>null</code>, then a
 <code>NullPointerException</code> is thrown.
 <p>
 If <code>source</code> is <code>null</code>, then a
 <code>NullPointerException</code> is thrown and the destination
 array is not modified.
 <p>
 Otherwise, if any of the following is true, an
 <code>ArrayStoreException</code> is thrown and the destination is
 not modified:
 <ul>
 <li>The <code>source</code> argument refers to an object that is not an
 	array.
 <li>The <code>target</code> argument refers to an object that is not an
 	array.
 <li>The <code>source</code> argument and <code>target</code> argument refer to
 	arrays whose component types are different primitive types.
 <li>The <code>source</code> argument refers to an array with a primitive
 	component type and the <code>target</code> argument refers to an array
 	with a reference component type.
 <li>The <code>source</code> argument refers to an array with a reference
 	component type and the <code>target</code> argument refers to an array
 	with a primitive component type.
 </ul>
 <p>
 Otherwise, if any of the following is true, an
 <code>IndexOutOfBoundsException</code> is
 thrown and the destination is not modified:
 <ul>
 <li>The <code>sourceOffset</code> argument is negative.
 <li>The <code>targetOffset</code> argument is negative.
 <li>The <code>size</code> argument is negative.
 <li><code>sourceOffset+size</code> is greater than
 	<code>source.length</code>, the length of the source array.
 <li><code>targetOffset+size</code> is greater than
 	<code>target.length</code>, the length of the destination array.
 </ul>
 <p>
 Otherwise, if any actual component of the source array from
 position <code>sourceOffset</code> through
 <code>sourceOffset+size-1</code> cannot be converted to the component
 type of the destination array by assignment conversion, an
 <code>ArrayStoreException</code> is thrown. In this case, let
 <b><i>k</i></b> be the smallest nonnegative integer less than
 length such that <code>source[sourceOffset+</code><i>k</i><code>]</code>
 cannot be converted to the component type of the destination
 array; when the exception is thrown, source array components from
 positions <code>sourceOffset</code> through
 <code>sourceOffset+</code><i>k</i><code>-1</code>
 will already have been copied to destination array positions
 <code>targetOffset</code> through
 <code>targetOffset+</code><i>k</I><code>-1</code> and no other
 positions of the destination array will have been modified.
 (Because of the restrictions already itemized, this
 paragraph effectively applies only to the situation where both
 arrays have component types that are reference types.)<p>
 This method calls <CODE>System.arraycopy(java.lang.Object, int, java.lang.Object, int, int)</CODE>.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source</CODE> - the source array.<DD><CODE>from</CODE> - start position in the source array.<DD><CODE>target</CODE> - the destination array.<DD><CODE>to</CODE> - start position in the destination data.<DD><CODE>size</CODE> - the number of array elements to be copied.<DT><B>Throws:</B><DD><A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/IndexOutOfBoundsException.html">IndexOutOfBoundsException</A> - if copying would cause
 		access of data outside array bounds.<DD>ArrayStoreException - if an element in the <code>source</code>
 		array could not be stored into the <code>target</code> array
 		because of a type mismatch.<DD><A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/NullPointerException.html">NullPointerException</A> - if either <code>source</code> or
 		<code>target</code> is <code>null</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="copy(java.lang.Object, java.lang.Object, int)"><!-- --></A><H3>
copy</H3>
<PRE>
public void <B>copy</B>(<A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html">Object</A>&nbsp;source,
                 <A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html">Object</A>&nbsp;target,
                 int&nbsp;size)</PRE>
<DL>
<DD>Copies an array from the specified source array at position 0
 to position 0 of the destination array.
 The number of components copied is
 equal to the <code>size</code> argument. The components at
 positions <code>sourceOffset</code> through
 <code>sourceOffset+length-1</code> in the source array are copied into
 positions <code>targetOffset</code> through
 <code>targetOffset+length-1</code>, respectively, of the destination
 array.
 <p>
 If the <code>source</code> and <code>target</code> arguments refer to the
 same array object, then the copying is performed as if the
 components at positions <code>0</code> through
 <code>size-1</code> were first copied to a temporary
 array with <code>size</code> components and then the contents of
 the temporary array were copied into positions
 <code>0</code> through <code>size-1</code> of the
 destination array.
 <p>
 If <code>target</code> is <code>null</code>, then a
 <code>NullPointerException</code> is thrown.
 <p>
 If <code>source</code> is <code>null</code>, then a
 <code>NullPointerException</code> is thrown and the destination
 array is not modified.
 <p>
 Otherwise, if any of the following is true, an
 <code>ArrayStoreException</code> is thrown and the destination is
 not modified:
 <ul>
 <li>The <code>source</code> argument refers to an object that is not an
 	array.
 <li>The <code>target</code> argument refers to an object that is not an
 	array.
 <li>The <code>source</code> argument and <code>target</code> argument refer to
 	arrays whose component types are different primitive types.
 <li>The <code>source</code> argument refers to an array with a primitive
 	component type and the <code>target</code> argument refers to an array
 	with a reference component type.
 <li>The <code>source</code> argument refers to an array with a reference
 	component type and the <code>target</code> argument refers to an array
 	with a primitive component type.
 </ul>
 <p>
 Otherwise, if any of the following is true, an
 <code>IndexOutOfBoundsException</code> is
 thrown and the destination is not modified:
 <ul>
 <li>The <code>size</code> argument is negative.
 </ul>
 <p>
 Otherwise, if any actual component of the source array from
 position <code>0</code> through
 <code>size-1</code> cannot be converted to the component
 type of the destination array by assignment conversion, an
 <code>ArrayStoreException</code> is thrown. In this case, let
 <b><i>k</i></b> be the smallest nonnegative integer less than
 length such that <code>source[</code><i>k</i><code>]</code>
 cannot be converted to the component type of the destination
 array; when the exception is thrown, source array components from
 positions <code>0</code> through
 <code></code><i>k</i><code>-1</code>
 will already have been copied to destination array positions
 <code>0</code> through
 <code></code><i>k</I><code>-1</code> and no other
 positions of the destination array will have been modified.
 (Because of the restrictions already itemized, this
 paragraph effectively applies only to the situation where both
 arrays have component types that are reference types.)
 This method calls:
 <br><br>
 <code><pre>
 	copy(source, 0, target, 0, size);
 </code></pre><DD><DL>
<DT><B>Parameters:</B><DD><CODE>source</CODE> - the source array.<DD><CODE>target</CODE> - the destination array.<DD><CODE>size</CODE> - the number of array elements to be copied.<DT><B>Throws:</B><DD><A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/IndexOutOfBoundsException.html">IndexOutOfBoundsException</A> - if copying would cause
 		access of data outside array bounds.<DD>ArrayStoreException - if an element in the <code>source</code>
 		array could not be stored into the <code>target</code> array
 		because of a type mismatch.<DD><A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/NullPointerException.html">NullPointerException</A> - if either <code>source</code> or
 		<code>target</code> is <code>null</code>.<DT><B>See Also: </B><DD><A HREF="../../xxl/util/ArrayResizer.html#copy(java.lang.Object, int, java.lang.Object, int, int)"><CODE>copy(Object, int, Object, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="resize(java.lang.Object, int)"><!-- --></A><H3>
resize</H3>
<PRE>
public <A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html">Object</A> <B>resize</B>(<A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html">Object</A>&nbsp;array,
                     int&nbsp;size)</PRE>
<DL>
<DD>Resizes a given (Object or primitive type) array.
 The minimum <tt>size</tt> (logical size) the array should have afer a contraction
 or an expanison has to be specified. <br>
 Depending on this logical size and the array's length the given
 array is expanded, i.e. <code>grow(array, size)</code> is called, or shrinked, i.e.
 <code>shrink(array, size)</code> is called.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - the array to be resized.<DD><CODE>size</CODE> - the minimal needed size of the array (logical size).<DT><B>Returns:</B><DD>the resized array is returned.<DT><B>Throws:</B><DD>ArrayStoreException - if an element in the <code>source</code>
 		array could not be stored into the <code>target</code> array
 		because of a type mismatch.<DD><A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/NullPointerException.html">NullPointerException</A> - if the given array is <code>null</code>.<DD><A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/IllegalArgumentException.html">IllegalArgumentException</A> - if the given object argument is not an array.<DT><B>See Also: </B><DD><A HREF="../../xxl/util/ArrayResizer.html#grow(java.lang.Object, int)"><CODE>grow(java.lang.Object, int)</CODE></A>, 
<A HREF="../../xxl/util/ArrayResizer.html#shrink(java.lang.Object, int)"><CODE>shrink(java.lang.Object, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="resize(java.lang.Object[], int)"><!-- --></A><H3>
resize</H3>
<PRE>
public <A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html">Object</A>[] <B>resize</B>(<A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html">Object</A>[]&nbsp;array,
                       int&nbsp;size)</PRE>
<DL>
<DD>Resizes a given Object-array. (no primitive types allowed)
 The minimum <tt>size</tt> (logical size) the array should have afer a contraction
 or an expanison has to be specified. <br>
 Depending on this logical size and the array's length the given
 array is expanded, i.e. <code>grow(array, size)</code> is called, or shrinked, i.e.
 <code>shrink(array, size)</code> is called.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - the Object-array to resized.<DD><CODE>size</CODE> - the minimal needed size of the array (logical size).<DT><B>Returns:</B><DD>the resized array is returned.<DT><B>Throws:</B><DD>ArrayStoreException - if an element in the <code>source</code>
 		array could not be stored into the <code>target</code> array
 		because of a type mismatch.<DD><A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/NullPointerException.html">NullPointerException</A> - if the given array is <code>null</code>.<DD><A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/IllegalArgumentException.html">IllegalArgumentException</A> - if the given object argument is not an array.<DT><B>See Also: </B><DD><A HREF="../../xxl/util/ArrayResizer.html#grow(java.lang.Object, int)"><CODE>grow(java.lang.Object, int)</CODE></A>, 
<A HREF="../../xxl/util/ArrayResizer.html#shrink(java.lang.Object, int)"><CODE>shrink(java.lang.Object, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="main(java.lang.String[])"><!-- --></A><H3>
main</H3>
<PRE>
public static void <B>main</B>(<A HREF="http://java.sun.com/products/jdk/1.2/docs/api/java/lang/String.html">String</A>[]&nbsp;args)</PRE>
<DL>
<DD>The main method contains some examples to demonstrate the usage
 and the functionality of this class.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>args</CODE> - array of <tt>String</tt> arguments. It can be used to
 		submit parameters when the main method is called.</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT ID="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT ID="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT ID="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT ID="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT ID="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<a href=http://www.mathematik.uni-marburg.de/DBS/xxl target=_parent><img src=xxl.gif border=0 alt=home-page></a></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../xxl/util/BitSet.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="ArrayResizer.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>

</BODY>
</HTML>
